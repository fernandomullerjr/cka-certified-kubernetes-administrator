#
# ###################################################################################################################### 
# ###################################################################################################################### 
#  push

git status
git add .
git commit -m "272. Mock Exam - 2 - Solution."
eval $(ssh-agent -s)
ssh-add /home/fernando/.ssh/chave-debian10-github
git push
git status


# ###################################################################################################################### 
# ###################################################################################################################### 
## 272. Mock Exam - 2 - Solution

Revisando Mock Exam 2


# ###################################################################################################################### 
# ###################################################################################################################### 
## 1 / 8
ETCDCTL_API=3 etcdctl snapshot save /opt/etcd-backup.db --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key



Para chegar nesta resposta

Na prova **CKA (Certified Kubernetes Administrator)**, √© essencial saber como obter as informa√ß√µes necess√°rias para formar o comando de backup do etcd. Aqui est√° como voc√™ pode proceder:

---

### **1. Verificar os par√¢metros do `etcdctl`**
Antes de tudo, voc√™ precisa entender os par√¢metros usados no comando:

- **`ETCDCTL_API=3`**: Define a vers√£o da API que ser√° usada. A vers√£o 3 √© a recomendada para etcd moderno.
- **`--endpoints`**: O endere√ßo do endpoint etcd (geralmente `https://127.0.0.1:2379` em clusters locais).
- **`--cacert`**: Caminho para o certificado da Autoridade Certificadora (CA) que valida a comunica√ß√£o SSL/TLS.
- **`--cert` e `--key`**: Certificado e chave privada do etcd para autentica√ß√£o.

---

### **2. Como encontrar os valores necess√°rios**
#### a. **Endere√ßo do etcd (`--endpoints`)**
- Normalmente, o etcd √© configurado no arquivo `/etc/kubernetes/manifests/etcd.yaml`, que define o Pod est√°tico para o etcd. Use o comando abaixo para verificar:

  ```bash
  cat /etc/kubernetes/manifests/etcd.yaml
  ```

  Busque por algo como:

  ```yaml
  - --listen-client-urls=https://127.0.0.1:2379
  ```

  O valor ser√° o endpoint do etcd. Na maioria dos casos, √© `https://127.0.0.1:2379`.

---

#### b. **Caminhos para certificados e chaves**
Os certificados s√£o geralmente gerados pelo kubeadm e podem ser encontrados em:

```bash
ls /etc/kubernetes/pki/etcd/
```

Voc√™ ver√° arquivos como:
- `ca.crt` (CA do etcd)
- `server.crt` (Certificado do servidor)
- `server.key` (Chave privada do servidor)

Estes caminhos s√£o usados para os par√¢metros `--cacert`, `--cert` e `--key`:

```bash
--cacert=/etc/kubernetes/pki/etcd/ca.crt
--cert=/etc/kubernetes/pki/etcd/server.crt
--key=/etc/kubernetes/pki/etcd/server.key
```

---

#### c. **Verificar configura√ß√µes com `kubectl`**
Se voc√™ n√£o tem certeza das configura√ß√µes, use o `kubectl` para acessar os detalhes do Pod etcd:

```bash
kubectl -n kube-system describe pod etcd-<nome-do-node>
```

Procure por argumentos que indiquem o endpoint, certificados ou configura√ß√µes adicionais.

---

### **3. Montando o comando completo**
Com base nas informa√ß√µes encontradas, o comando ficar√° assim:

```bash
ETCDCTL_API=3 etcdctl snapshot save /opt/etcd-backup.db \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key
```

---

### **4. Testando o comando**
Sempre teste o comando antes de confiar no backup:

```bash
ETCDCTL_API=3 etcdctl snapshot status /opt/etcd-backup.db
```

Se o backup foi bem-sucedido, voc√™ ver√° informa√ß√µes como tamanho do arquivo e a revis√£o do etcd.

---

Caso encontre dificuldades durante a prova, priorize usar o `kubectl` para inspecionar os Pods e arquivos de configura√ß√£o em `/etc/kubernetes/manifests`. Boa sorte! üòä



Para descobrir as informa√ß√µes necess√°rias para formar este comando de backup do etcd no Kubernetes, voc√™ pode seguir estes passos:

1. Primeiro, conecte-se ao n√≥ master/control-plane do cluster onde o etcd est√° rodando usando:
```bash
ssh <node-name>
```

2. Para encontrar os caminhos dos certificados e chaves, voc√™ pode:
```bash
kubectl describe pod -n kube-system etcd-<master-node-name>
```
Ou verificar diretamente no diret√≥rio padr√£o:
```bash
ls -l /etc/kubernetes/pki/etcd/
```

3. Para confirmar o endpoint do etcd, voc√™ pode:
```bash
kubectl get pods -n kube-system | grep etcd
```
E depois verificar as configura√ß√µes:
```bash
docker ps | grep etcd
# ou
crictl ps | grep etcd
```

4. Voc√™ tamb√©m pode verificar as configura√ß√µes do etcd usando:
```bash
cat /etc/kubernetes/manifests/etcd.yaml
```

Este arquivo yaml geralmente cont√©m todas as informa√ß√µes necess√°rias, incluindo:
- Localiza√ß√£o dos certificados
- Endpoint do etcd
- Configura√ß√µes da API

Na prova CKA, estas informa√ß√µes geralmente est√£o dispon√≠veis no pr√≥prio ambiente de teste, e voc√™ pode usar estes comandos para encontr√°-las. O diret√≥rio `/etc/kubernetes/pki/etcd/` √© o local padr√£o para os certificados do etcd no Kubernetes.










# ###################################################################################################################### 
# ###################################################################################################################### 
### 2 / 8

- Ajustado, Pod com EmptyDir:

~~~~yaml
apiVersion: v1
kind: Pod
metadata:
  name: redis-storage
spec:
  containers:
  - image: redis:alpine
    name: redis-storage
    volumeMounts:
    - mountPath: /data/redis
      name: redis-storage-volume
  volumes:
  - name: redis-storage-volume
    emptyDir:
      sizeLimit: 500Mi
~~~~

https://kubernetes.io/docs/concepts/storage/volumes/

emptyDir

For a Pod that defines an emptyDir volume, the volume is created when the Pod is assigned to a node. As the name says, the emptyDir volume is initially empty. All containers in the Pod can read and write the same files in the emptyDir volume, though that volume can be mounted at the same or different paths in each container. When a Pod is removed from a node for any reason, the data in the emptyDir is deleted permanently.
Note:
A container crashing does not remove a Pod from a node. The data in an emptyDir volume is safe across container crashes.

Some uses for an emptyDir are:

    scratch space, such as for a disk-based merge sort
    checkpointing a long computation for recovery from crashes
    holding files that a content-manager container fetches while a webserver container serves the data

The emptyDir.medium field controls where emptyDir volumes are stored. By default emptyDir volumes are stored on whatever medium that backs the node such as disk, SSD, or network storage, depending on your environment. If you set the emptyDir.medium field to "Memory", Kubernetes mounts a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast be aware that, unlike disks, files you write count against the memory limit of the container that wrote them.

A size limit can be specified for the default medium, which limits the capacity of the emptyDir volume. The storage is allocated from node ephemeral storage. If that is filled up from another source (for example, log files or image overlays), the emptyDir may run out of capacity before this limit. If no size is specified, memory backed volumes are sized to node allocatable memory.
Caution:
Please check here for points to note in terms of resource management when using memory-backed emptyDir.
emptyDir configuration example

apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir:
      sizeLimit: 500Mi


O volume **`emptyDir`** no Kubernetes √© uma solu√ß√£o de armazenamento tempor√°rio que pode ser usada para compartilhar dados entre os cont√™ineres de um mesmo Pod. Ele √© criado automaticamente quando o Pod √© agendado em um n√≥ e √© exclu√≠do permanentemente assim que o Pod deixa o n√≥, independentemente da raz√£o (ex: exclus√£o, realoca√ß√£o, etc.).

Aqui est√£o os principais detalhes sobre como funciona o **`emptyDir`**:

---

### **1. Caracter√≠sticas principais do `emptyDir`**

- **Inicialmente vazio**: Quando o Pod √© iniciado, o volume come√ßa vazio, pronto para ser usado pelos cont√™ineres do Pod.
  
- **Compartilhamento entre cont√™ineres**: Todos os cont√™ineres do Pod podem acessar o volume `emptyDir`. Ele pode ser montado no mesmo ou em diferentes caminhos em cada cont√™iner.

- **Persist√™ncia durante o ciclo de vida do Pod**:
  - Os dados permanecem dispon√≠veis enquanto o Pod est√° ativo no n√≥.
  - Se um cont√™iner no Pod falhar (crash), os dados ainda estar√£o dispon√≠veis para outros cont√™ineres no Pod.
  - Quando o Pod √© exclu√≠do ou realocado para outro n√≥, todos os dados no `emptyDir` s√£o perdidos.

---

### **2. Tipos de armazenamento com `emptyDir.medium`**

O comportamento do volume pode variar dependendo da configura√ß√£o da propriedade `emptyDir.medium`:

- **Padr√£o (armazenamento em disco)**:
  - Se `medium` n√£o for especificado, o volume usa o armazenamento local do n√≥ (disco, SSD ou outro meio f√≠sico configurado).
  - √â √∫til para armazenamento tempor√°rio persistente dentro do ciclo de vida do Pod.

- **RAM (`medium: "Memory"`)**:
  - Define o volume como um **`tmpfs`**, ou seja, um sistema de arquivos armazenado na mem√≥ria (RAM).
  - √â muito mais r√°pido que o armazenamento em disco.
  - Arquivos armazenados consomem a mem√≥ria do n√≥ e contam como uso de mem√≥ria para os limites do cont√™iner.

---

### **3. Configura√ß√£o de tamanho (`sizeLimit`)**

- Um limite de tamanho pode ser especificado para restringir o uso do volume:
  ```yaml
  emptyDir:
    sizeLimit: 500Mi
  ```
- Este valor √© aplicado apenas se o volume usar o meio padr√£o (disco). O espa√ßo √© alocado a partir do armazenamento ef√™mero do n√≥.
- Para volumes em mem√≥ria (`medium: "Memory"`), o limite √© proporcional √† mem√≥ria dispon√≠vel no n√≥.

---

### **4. Exemplos de uso**

- **Espa√ßo de trabalho tempor√°rio**:
  - Para armazenar dados intermedi√°rios em opera√ß√µes como ordena√ß√£o ou c√°lculos.
  
- **Checkpoint de tarefas longas**:
  - Para salvar dados durante a execu√ß√£o de tarefas longas, permitindo recupera√ß√£o em caso de falhas.
  
- **Armazenamento de arquivos tempor√°rios para m√∫ltiplos cont√™ineres**:
  - Um cont√™iner pode fazer download de conte√∫do que ser√° servido por outro cont√™iner.

---

### **5. Exemplo de configura√ß√£o**

O exemplo a seguir demonstra como configurar um Pod com um volume `emptyDir`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - name: test-container
    image: registry.k8s.io/test-webserver
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir:
      medium: "Memory" # Armazenar na mem√≥ria (RAM)
      sizeLimit: 500Mi # Limite de 500Mi
```

Nesse exemplo:
- O volume `cache-volume` √© montado no caminho `/cache` do cont√™iner.
- Os arquivos armazenados no volume s√£o salvos na mem√≥ria (RAM) com um limite de 500Mi.

---

### **6. Pontos importantes sobre o `emptyDir`**

- **Perda de dados**: Os dados s√£o vol√°teis e desaparecem quando o Pod √© destru√≠do.
- **Uso respons√°vel da mem√≥ria**: Para volumes baseados em mem√≥ria (`tmpfs`), os arquivos consomem mem√≥ria, e isso pode afetar o desempenho do cont√™iner se n√£o for gerenciado corretamente.
- **Armazenamento limitado**: O volume √© restrito ao espa√ßo dispon√≠vel no n√≥, seja na mem√≥ria ou no armazenamento ef√™mero.

---










# ###################################################################################################################### 
# ###################################################################################################################### 
##
### 3 / 8

- Ajustado:

~~~~yaml
apiVersion: v1
kind: Pod
metadata:
  name: super-user-pod
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    supplementalGroups: [4000]
  volumes:
  - name: super-user-pod-ctx-vol
    emptyDir: {}
  containers:
  - name: super-user-pod
    image: busybox:1.28
    command: [ "sh", "-c", "sleep 4800" ]
    volumeMounts:
    - name: super-user-pod-ctx-vol
      mountPath: /data/demo
    securityContext:
      capabilities:
        add: ["NET_ADMIN", "SYS_TIME"]
~~~~



https://kubernetes.io/docs/tasks/configure-pod-container/security-context/

Here is the configuration file for a Pod that runs one Container. The configuration adds the CAP_NET_ADMIN and CAP_SYS_TIME capabilities:
pods/security/security-context-4.yaml [Copy pods/security/security-context-4.yaml to clipboard]

apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo-4
spec:
  containers:
  - name: sec-ctx-4
    image: gcr.io/google-samples/hello-app:2.0
    securityContext:
      capabilities:
        add: ["NET_ADMIN", "SYS_TIME"]




### 4 / 8

- PVC Ajustado:

~~~~yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Mi
  storageClassName: "" # Empty string must be explicitly set otherwise default StorageClass will be set
  volumeName: pv-1
~~~~

- Criando Pod com PVC:

~~~~yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: use-pv
  name: use-pv
spec:
  containers:
    - name: use-pv
      image: nginx
      volumeMounts:
      - mountPath: "/data"
        name: mypd
  dnsPolicy: ClusterFirst
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: my-pvc
~~~~






### 5 / 8

- Deployment Ajustado:

~~~~yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.16
        ports:
        - containerPort: 80
~~~~

- Setando nova imagem:
 kubectl set image deployment/nginx-deploy nginx=nginx:1.17







### 6 / 8

cat /root/CKA/john.csr | base64 | tr -d "\n"
kubectl apply -f 271-csr.yaml 
kubectl certificate approve john-developer
kubectl get csr john-developer -o jsonpath='{.status.certificate}' | base64 -d > /root/CKA/john.crt
kubectl apply -f 271-role-developer.yaml
kubectl apply -f 271-rolebinding-john.yaml
kubectl apply -f 271-clusterrole-create.yaml 
kubectl apply -f 271-clusterrole-approve.yaml 
kubectl apply -f 271-clusterrole-sign.yaml 
kubectl get csr
kubectl certificate approve john
kubectl get csr

- Solu√ß√£o proposta pela KodeKloud:

~~~~yaml
 apiVersion: certificates.k8s.io/v1
 kind: CertificateSigningRequest
 metadata:
   name: john-developer
 spec:
   signerName: kubernetes.io/kube-apiserver-client
   request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFBd0R6RU5NQXNHQTFVRUF3d0VhbTlvYmpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRApnZ0VQQURDQ0FRb0NnZ0VCQUt2Um1tQ0h2ZjBrTHNldlF3aWVKSzcrVVdRck04ZGtkdzkyYUJTdG1uUVNhMGFPCjV3c3cwbVZyNkNjcEJFRmVreHk5NUVydkgyTHhqQTNiSHVsTVVub2ZkUU9rbjYra1NNY2o3TzdWYlBld2k2OEIKa3JoM2prRFNuZGFvV1NPWXBKOFg1WUZ5c2ZvNUpxby82YU92czFGcEc3bm5SMG1JYWpySTlNVVFEdTVncGw4bgpjakY0TG4vQ3NEb3o3QXNadEgwcVpwc0dXYVpURTBKOWNrQmswZWhiV2tMeDJUK3pEYzlmaDVIMjZsSE4zbHM4CktiSlRuSnY3WDFsNndCeTN5WUFUSXRNclpUR28wZ2c1QS9uREZ4SXdHcXNlMTdLZDRaa1k3RDJIZ3R4UytkMEMKMTNBeHNVdzQyWVZ6ZzhkYXJzVGRMZzcxQ2NaanRxdS9YSmlyQmxVQ0F3RUFBYUFBTUEwR0NTcUdTSWIzRFFFQgpDd1VBQTRJQkFRQ1VKTnNMelBKczB2czlGTTVpUzJ0akMyaVYvdXptcmwxTGNUTStsbXpSODNsS09uL0NoMTZlClNLNHplRlFtbGF0c0hCOGZBU2ZhQnRaOUJ2UnVlMUZnbHk1b2VuTk5LaW9FMnc3TUx1a0oyODBWRWFxUjN2SSsKNzRiNnduNkhYclJsYVhaM25VMTFQVTlsT3RBSGxQeDNYVWpCVk5QaGhlUlBmR3p3TTRselZuQW5mNm96bEtxSgpvT3RORStlZ2FYWDdvc3BvZmdWZWVqc25Yd0RjZ05pSFFTbDgzSkljUCtjOVBHMDJtNyt0NmpJU3VoRllTVjZtCmlqblNucHBKZWhFUGxPMkFNcmJzU0VpaFB1N294Wm9iZDFtdWF4bWtVa0NoSzZLeGV0RjVEdWhRMi80NEMvSDIKOWk1bnpMMlRST3RndGRJZjAveUF5N05COHlOY3FPR0QKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==
   usages:
   - digital signature
   - key encipherment
   - client auth
   groups:
   - system:authenticated
~~~~

~~~~bash
 kubectl certificate approve john-developer
 kubectl create role developer --resource=pods --verb=create,list,get,update,delete --namespace=development
 kubectl create rolebinding developer-role-binding --role=developer --user=john --namespace=development
 kubectl auth can-i update pods --as=john --namespace=development
~~~~





# ###################################################################################################################### 
# ###################################################################################################################### 
## RESUMO - DICAS

---
- Verificar as configura√ß√µes do etcd usando:

~~~~bash
cat /etc/kubernetes/manifests/etcd.yaml
~~~~

Este arquivo yaml geralmente cont√©m todas as informa√ß√µes necess√°rias, incluindo:
- Localiza√ß√£o dos certificados
- Endpoint do etcd
- Configura√ß√µes da API


---
**Caracter√≠sticas principais do `emptyDir`**

- **Inicialmente vazio**: Quando o Pod √© iniciado, o volume come√ßa vazio, pronto para ser usado pelos cont√™ineres do Pod.
  
- **Compartilhamento entre cont√™ineres**: Todos os cont√™ineres do Pod podem acessar o volume `emptyDir`. Ele pode ser montado no mesmo ou em diferentes caminhos em cada cont√™iner.

- **Persist√™ncia durante o ciclo de vida do Pod**:
  - Os dados permanecem dispon√≠veis enquanto o Pod est√° ativo no n√≥.
  - Se um cont√™iner no Pod falhar (crash), os dados ainda estar√£o dispon√≠veis para outros cont√™ineres no Pod.
  - Quando o Pod √© exclu√≠do ou realocado para outro n√≥, todos os dados no `emptyDir` s√£o perdidos.


---
- Configurando Capabilities:

~~~~yaml
    securityContext:
      capabilities:
        add: ["NET_ADMIN", "SYS_TIME"]
~~~~


---
- Cuidar a capacidade do PV vs a capacidade "solicitada pelo "PVC".


---
- Importante lembrar de transformar em base64 o certificado a ser utilizado no campo "request" do recurso "CertificateSigningRequest":
cat /root/CKA/john.csr | base64 | tr -d "\n"